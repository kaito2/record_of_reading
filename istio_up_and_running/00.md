# istio: Up and Running 0
#istio_up_and_running

## Fundamentals
Istio (service mesh) のメリット
- democratization of language
- network の関心を分離し、オペレータが制御できる
	- SDN っぽい


[image:C75919B3-9118-4830-9878-F2779E2C89D2-32573-000091BD1101FB36/iuar_0101.png]

Service mesh は コントロールプレーンとデータプレーン(service proxy)にわかれる
コントロールプレーンはpodのiptableのルールを変更しトラフィックをInterceptする

istio はすべてのネットワークパスにプロキシ(データプレーン)を注入し、それらを集中管理することでサービスメッシュを形成している

## Sailing into a Service Mesh
サービスの数が多くなるほど管理する苦しみは大きくなっていくのでタスクに関係なくサービスメッシュを導入する機運はある。

### Client Libraries: The First Service Meshes?

[image:4AA38007-AEB2-4183-AB10-C20EDB030882-32573-0000937A1215CE9A/iuar_0102.png]

クライアントライブラリとしてサービスメッシュを実現する場合は以下のようなことが起こる
- cons
	- 多言語対応
- pros
	- 消費するリソース(サービスの呼び出し?)がローカルになる
	- 開発者は既存のライブラリを使うか新しい言語のクライアント開発を選択できる

しかし…
時間が経つにつれてクライアントライブラリを使う弊害が顕在化してきた。

最も大きな弊害は
**アプリケーションコードにインフラ層の関心が入り込んでしまっている**という点である

他にも以下のようなデメリットもあった
言語間で性能や機能の不均一も生まれ o11y が損なわれた
各のコンポーネントに制御する権限を与えることでセキュリティも低下する


> brownfield applications
≒ レガシー??

このような言語ごとのライブラリは既存のアーキテクチャ(特にレガシーでは)に組み込むことが難しい(コストが高い)。


ネットワークは難しい(そう)。
- ジッター
- バックオフ
- リトライ制御
むずかしい。かつ言語の仕様で変わる。

入っているクライアントをすべてアップデートするのは難しい(アプリケーションコードに修正が必要)
アプリケーションにダウンタイムも発生する

以下の図が次なる構成で、サービスプロキシを各サービスのサイドカーとして設置している
これにより言語固有の実装が不要になる(circuit breaking, timeouts, retries, service discovery, load balancing, and so on)
これにより組織は1つのプラットフォーム上にライブラリを使えるかどうかに関して心配せずに実装できることを約束したかのように見えた。

[image:862CAF69-E69D-4A90-8D41-4C8BD5DF1ACE-32573-000094644E19ED74/iuar_0103.png]

## Why Do You Need One?
この段階であなたは以下のように感じるでしょう

> “I have a container orchestrator. Why do I need another infrastructure layer?”

コンテナオーケストレーターの主な目的は以下のようになっているため、マイクロサービスに関する機能は対応されていません。

- scheduling
- discovery
- health

サービスメッシュは コンテナオーケストレーターや別のサービスディスカバリシステムとの結合に依存することもあるサービス感通信を

- 安全に
- 高速に
- 信頼性を高く

するための専用のインフラストラクチャレイヤーである

**どんな目的でサービスメッシュを採用するのか**

- o11y のため
- サービス感通信の暗号化のため

サービスメッシュはコンテナイズされたクラウドネイティブなアーキテクチャ以外にも有効である

**コンテナオーケストレーションシステムは単純なネットワークの関心事をアプリケーション層からインフラストラクチャ層へ移動している。**

## Landscape
L7プロキシ(LB)をラップするアプローチ
- HAProxy
- Traefik
- NGINX
- Envoy

gateway を起点とするために north-south のトラフィックを想定しているが、 east-west のトラフィックには対応していない(すべてがgatewayを通過するため)
サービスメッシュは更に広い機能を提供する

ネットワークを中央管理し、ネットワークを `intelligent and resilient`  にするためには以下の機能を備えている必要がある

- 障害を回避してトラフィックをルーティングする(クラスタネットワークの信頼性の向上)
- 待ち時間の長いルートやコードルドキャッシュを備えているサーバなどの不要なオーバーヘッドを回避する
- サービス間を流れるトラフィックが攻撃に対して安全であることを確認する
- 予期しない依存関係やサービス通信障害の根本的な原因を強調する
- サービス粒度でポリシーを設定できる(接続粒度ではない。おそらく煩雑すぎるので)

加えて あなたはこれらのロジックをアプリケーションに組み込まずに済む必要がある

## The value of service mesh
以下の統一的な方式を提供する

- connect
- secure
- manage
- monitor

### Observability
サービスメッシュは可視性・弾力性・トラフィック管理に加えて分散システム間におけるセキュリティ制御を可能にする。これだけで多大な価値が約束される。
サービスメッシュは透過的にデプロイされ、アプリケーションのコードの変更は必要ない

### Traffic control
ネットワークトラフィックを細かく宣言的に制御する。(カナリアリリースなど)
**resiliency** には遅延を考慮した負荷分散、サーキットブレイク、一貫したサービスディスカバリ、リトライ処理、タイムアウト、デッドラインなどが含まれる(詳しくは8章)


### Security
組織でサービスメッシュを利用する場合はセキュリティポリシーや社内コンプライアンスに関する強力なツールとして活用できる。

大抵のサービスメッシュは **certificate authority (CA)** を提供し、鍵と証明書を管理する。
サービス単位でIDを割り当てることでどのクライアントが異なるサービスにリクエスト可能かを決定し、トラフィックを暗号化するために重要である。

一般的に証明書のライフサイクル管理(生成、配布、更新、失効)やサービスのIDを取得はサービスプロキシ(5章)が代行する。(詳細については6章)

### Modernizing your existing infrastructure (retrofitting a deployment)
多くの人は多くのサービスが実行されていない場合はサービスメッシュアーキテクチャは必要ないと考える。これは真ではない。
サービスメッシュは実行されているサービスの数には関係なく価値を提供する。

サービスメッシュはアプリケーションコードを変更したり、マイクロサービス仕様に変更したり、新しい言語で実装したりクラウドへ移行したりせずともサービスをモダナイズすることができる。

**[イワツキ]: モダナイズってなんだ**

モノリスをブレークダウンしていくのに **facade service** を使用することができる。
ref. [Facade パターン - Wikipedia](https://ja.wikipedia.org/wiki/Facade_%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3)

また、**strangler pattern** を使用することで開発者に優しいAPIの集合へ移行することができる。
ref. [Strangler pattern - Cloud Design Patterns | Microsoft Docs](https://docs.microsoft.com/en-us/azure/architecture/patterns/strangler)

トレーシングに関してサービス内で必要な唯一の変更はHTTPヘッダに特定の値を埋め込むことである。サービスメッシュはコードの変更を最小限に抑えて、既存のインフラを均一かつ偏在する観測をレトロフィットするのに役立つ。

### Decoupling at layer 5
マイクロサービスを利用すると機能ごとにチームを分離する事ができるのと同じようにサービスメッシュを利用するとオペレーターがアプリケーション機能の開発・リリースプロセスから分離され、サービスレイヤの実行方法をオペレーターが宣言的に制御できるようになる。

チーム間の責任の境界を明確に定義できる。例えば以下のようなタスクを想定する。

- いつサーキット・ブレイクするか、そしてそれらの交渉
	- [マイクロサービスにおけるサーキットブレーカーとは（簡易まとめ） - コード日進月歩](https://shinkufencer.hateblo.jp/entry/2018/10/26/000000)
- エンドツーエンドのサービス期限を設定する
- 分散トレーシングの生成を保証し、モニタリングシステムへ送信する
- 特定ユーザーのベータ版へのアクセスを拒否する

これらのタスクは開発者またはオペレーターのどちらの役割か??
回答は組織によって異なる、業界として一般的に受け入れられているプラクティスはない。
サービスメッシュが境界を定義するためにこれらの問題を解決できる(サービスメッシュが標準を作る?)。

