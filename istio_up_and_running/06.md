# istio: Up and Running 6. Security and Identity

現在は firewall や VPN などにより外部からの攻撃を防いでいることに加え、 networking isolation や IPアドレスで穴あけを行ったりなどをセキュリティのために行っている。これらの対策は数日で変更があるようなアプリケーションにおいては有効である。しかし、秒単位で構成が代わっていくような現在のアプリケーションのニーズは満たせない。

重要な問題は従来のネットワークはネットワークで使用できる唯一のIDであるIPアドレスに重点が置かれていることである。

Kubernetes のような動的な環境においてはIPアドレスは十分なIDになり得ない。

この問題に対処するための istio の主要な機能はサービスメッシュ内のすべてのワークロードにIDを発行する機能である。これらのIDはワークロードに紐づく。これはネットワークに縛られない *service-to-service authentication* が行えることを意味する。

この章では *service-to-service* 通信に関わる *identity*, *authorization*, *authentication* について見ていく。

## Access Control

Access Control の基本は 「*entity* は *object* に対して *action* を実行できるか?」 ということである。この *entity* を **"principal"** と呼ぶ。 *Action* はシステムが定義するいくつかのオペレーションある。*Object* は **principal** によって処理されるものである。

Unix のファイルシステムを例に挙げると、 *actions* は "read", "write" または "execute" の操作を file (*object*) に特定ユーザー (*principal*) 行うことに対応する。

### Authentication

Authentication は principal についてです。
Authentication は資格情報 (credential) を取得し、資格情報が有効であること(つまり、資格情報が本物であること) を検証し、entity を表すアイデンティティが含まれているかを確認するプロセスである。

Authentication (authn) はリクエストから資格情報を取得し、それが本物かを確認する行為である。
Istio 内ではサービスが他のサービスと通信する際には **X.509 certificate** を用いる。
Service proxy は呼び出し元の X.509 certificate を検証する(同様にクライアント側もサーバーのものを確認する)。
Authn が完了すると、 principal は *authenticated* 状態になる。この状態になった principal を *authenticated principal* と呼ぶ。

### Authorization

Authorization (authz) は "is entity allowed to perform action on object?" に答える行為である。
例えば、Unix システムでユーザーがあるスクリプトファイルを実行可能かチェックするようなものである。
Istio では service-to-service の通信は RBAC によって設定される(後述)。


> **_NOTE_**: "auth" は authn と authz の両方をあらわす。

アクセス制御の "can entity perform action ON object?" を考えると、 authn と authz はどちらも必要かつ、片方だけでは役に立たないという事がわかる。

付け加えると istio は "can entity perform action on object?" よりも少し具体的である。
Istio は "Can Service A perform action on Service B?" という質問に答える。
言い換えると、 *entity* と *object* はサービスメッシュ内のサービスのIDに該当する。

これらをふまえると次のような疑問が出てくる:

- Identity (ID) とは何でPrincipal とは誰か?
- サービスメッシュはどのようにして実行時に identity を管理しているのか?
- サービスが実行可能なポリシーをどのように記述し、istioは実行中にどのように反映しているのか?

この章の残りでこれらの疑問に答えていく。

### Identity

サービスメッシュの範囲はどこまで??
*administrative domain* という概念がこの疑問への回答となる。

ひとつのサービスメッシュにはある管理者がおり、もうひとつのサービスメッシュには他の管理者がいる。このような状況への回答は "a service mesh is a single identity domain." である。
言い換えると、 `namespace` でサービスメッシュのIDを特定する。

Identity はサービスメッシュの境界を構成する。
すべての通信は Identity から生まれるという点で、 Identity はサービスメッシュの基本的な機能である。

サービスメッシュの Traffic steering と Telemetry 機能はどのようにサービスを特定(identify)するかの理解に基づいている。(計測対象を把握していないとメトリクスは役に立たないデータになる)

Istio は *Secure Production Identity Framework for Everyone (SPIFFE)* 規格を identity を発行するために実装している。
簡単に言うと、 istio は X.509 certificate を作成する。 X.509 certificate の *subject alternative name (SAN)* が URI にセットされる。istio は プラットフォームの identity attributes に従う。Kubernetes の deployment において、 istio は Pod のサービスアカウントをURI(`spiffe://ClusterName/ns/Namespace/sa/ServiceAccountName` の形式) にエンコード identity として用います。

SPIFFE は identity をブートストラップして発行できるフレームワークである。

SPIRE (the SPIFFE Runtime Environement) は SPIFFE コミュニティの参考実装である。
Citadel (旧 istio auth) は2つ目の実装である。

SPIFFE の仕様は以下の3つを記述している

- Identity (URI形式) はサービスが通信を行うために利用する。
- 上記の identity を *SPIFFE Verifiable Identity Document (SVID)* へエンコードするための標準エンコーディング
- SVID を発行及び取得するためのAPI (Workload API)

SPIFFE は service の identity を *spiffe* スキーマの URI (like: `spiffe://trust-domain/path`) にエンコードすることを要求する。
`trust-domain` は信頼の起点をあらわす(e.g. `organization`, `environment`, `team`)。
`trust-domain` は URI の authority フィールドです(具体的には authority の `host sectio`)。
`path` セクションは任意の URI (UUIDや trust hierarchy または なにもなし) を許容する。

Istio on Kubernetes では cluster name を `trust-domain` として用いる。
そして、 **ServiceAccount** と namespace を用いて path を作成する。
たとえば、`spiffe://cluster.local/ns/default/sa/default` のようになる。


